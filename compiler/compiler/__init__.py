import sys
from typing import List, Optional

from lang_ast import MethodDecl, _Statement, PrintStmt, CallStmt, VarStmt, IntExpr, StringExpr, CallExpr, LocalExpr, \
    IfStmt, _Expression, Block

class UnitContext:
    strings: dict[str, str] = {}

    def get_string(self, string: str) -> str:
        existing = self.strings.get(string)
        if existing is not None:
            return existing

        index = len(self.strings)
        name = f"$str_{index}"
        self.strings[string] = name
        return name

class MethodContext:
    if_index = -1

    def new_if(self) -> int:
        self.if_index += 1
        return self.if_index

def eval_call_expr(f, expr: CallExpr, unitCtx: UnitContext, *, prefix=""):
    idx = 0

    def dfs(node: CallExpr, *, root=False):
        nonlocal idx

        ir_args = []
        for arg in node.args.exprs:
            if isinstance(arg, CallExpr):
                dfs(arg)
                ir_args.append(f"l %tmp{idx-1}")
            elif isinstance(arg, IntExpr):
                ir_args.append(f"l {arg.value}")
            elif isinstance(arg, StringExpr):
                ir_args.append(f"l {unitCtx.get_string(arg.value)}")
            elif isinstance(arg, LocalExpr):
                ir_args.append(f"l %{arg.local_name}")

        name_parts = node.full_name.parts
        assert len(name_parts) == 2
        class_name = unitCtx.get_string(name_parts[0])
        method_name = unitCtx.get_string(name_parts[1])
        f.write(f"\t%fn_ptr =l call $zre_method_static(l {class_name}, l {method_name})\n")

        f.write("\t")
        if not root:
            f.write(f"%tmp{idx} =l ")
        else:
            f.write(prefix)
        f.write(f"call %fn_ptr({", ".join(ir_args)}) # {name_parts[0]}.{name_parts[1]} \n")
        idx += 1

    dfs(expr, root=True)

def compile_if_stmt(f, stmt: IfStmt, unitCtx: UnitContext, mCtx: MethodContext):
    if not isinstance(stmt.expr, LocalExpr):
        sys.exit("if statement can only accept locals for now")

    idx = mCtx.new_if()
    true_label = f"@if{idx}_true"
    false_label = f"@if{idx}_false"
    end_label = f"@if{idx}_end"
    f.write(f"\tjnz %{stmt.expr.local_name}, {true_label}, {false_label}\n")

    f.write(f"{true_label}\n")
    for block_stmt in stmt.block.stmts:
        compile_stmt(f, block_stmt, unitCtx, mCtx)
    f.write(f"\tjmp {end_label}\n")

    f.write(f"{false_label}\n")
    if stmt.elseIfExpr is not None:
        nested_if = IfStmt(
            expr=stmt.elseIfExpr,
            block=stmt.elseIfBlock,
            elseIfExpr=None,
            elseIfBlock=None,
            elseBlock=stmt.elseBlock
        )
        compile_if_stmt(f, nested_if, unitCtx, mCtx)
    elif stmt.elseBlock is not None:
        for block_stmt in stmt.elseBlock.stmts:
            compile_stmt(f, block_stmt, unitCtx, mCtx)

    f.write(f"{end_label}\n")

def compile_stmt(f, stmt: _Statement, unitCtx: UnitContext, mCtx: MethodContext):
    if isinstance(stmt, VarStmt):
        if isinstance(stmt.expr, IntExpr):
            f.write(f"\t%{stmt.local_name} =l copy {stmt.expr.value}\n")
        elif isinstance(stmt.expr, StringExpr):
            string = unitCtx.get_string(stmt.expr.value)
            f.write(f"\t%{stmt.local_name} =l copy {string}\n")
        elif isinstance(stmt.expr, LocalExpr):
            f.write(f"\t%{stmt.local_name} =l copy {stmt.expr.local_name}\n")
        elif isinstance(stmt.expr, CallExpr):
            eval_call_expr(f, stmt.expr, unitCtx, prefix=f"%{stmt.local_name} =l ")

    elif isinstance(stmt, CallStmt):
        eval_call_expr(f, stmt.expr, unitCtx)

    elif isinstance(stmt, PrintStmt):
        if isinstance(stmt.expr, IntExpr):
            f.write(f"\tcall $zre_print_int(l {stmt.expr.value})\n")
        elif isinstance(stmt.expr, StringExpr):
            string = unitCtx.get_string(stmt.expr.value)
            f.write(f"\tcall $zre_print_string(l {string})\n")
        elif isinstance(stmt.expr, LocalExpr):
            f.write(f"\tcall $zre_print_obj(l %{stmt.expr.local_name})\n")
        elif isinstance(stmt.expr, CallExpr):
            eval_call_expr(f, stmt.expr, unitCtx, prefix=f"%tmp0 =l ")
            f.write(f"\tcall $zre_print_obj(l %tmp0)\n")

    elif isinstance(stmt, IfStmt):
        compile_if_stmt(f, stmt, unitCtx, mCtx)

    else:
        sys.exit(f"Unknown stmt {type(stmt)}")

def compile_method(f, method: MethodDecl, unitCtx: UnitContext):
    mCtx = MethodContext()

    f.write(f"export function l $User__{method.name}() {{\n")
    f.write("@start\n")
    for stmt in method.block.stmts:
        compile_stmt(f, stmt, unitCtx, mCtx)
    f.write("\tret\n")
    f.write("}\n")

def compile_ir(f, methods: List[MethodDecl]):
    f.write("# ==== Generated by qbe-lang ==== \n\n")

    unitCtx = UnitContext()

    for method in methods:
        compile_method(f, method, unitCtx)

    for string, name in unitCtx.strings.items():
        f.write(f"data {name} = {{ b \"{string}\", b 0 }}\n")