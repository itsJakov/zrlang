import sys

from compiler.unit_context import UnitContext
from lang_ast import ClassDecl, ClassField, MethodDecl, VarStmt, _Statement, IntExpr, LocalExpr, AllocExpr


def compile_block(f, block: list[_Statement], unit_ctx: UnitContext):
    for stmt in block:
        if isinstance(stmt, VarStmt):
            if stmt.expr is None:
                f.write(f"\t%{stmt.local} =l copy 0\n")
            elif isinstance(stmt.expr, IntExpr):
                f.write(f"\t%{stmt.local} =l copy {stmt.expr.value}\n")
            elif isinstance(stmt.expr, LocalExpr):
                f.write(f"\t%{stmt.local} =l copy %{stmt.expr.local}\n")
            elif isinstance(stmt.expr, AllocExpr):
                f.write(f"\t%{stmt.local} =l call $zre_alloc(l ${stmt.expr.cls_name})\n")
        else:
            sys.exit("Statement not supported yet!")

def compile_method(f, method: MethodDecl, cls: ClassDecl, unit_ctx: UnitContext):
    f.write(f"function l ${cls.name}_{method.name}(l %self) {{\n")
    f.write("@start\n")
    compile_block(f, method.block, unit_ctx)
    f.write("\tret\n")
    f.write("}\n")

def compile_cls(f, cls: ClassDecl, unit_ctx: UnitContext):
    f.write(f"# ==== \"{cls.name}\" Class Definition ==== \n")
    fields: list[ClassField] = list(filter(lambda x: isinstance(x, ClassField), cls.members))
    f.write(f"data ${cls.name}_fields = {{\n")
    for field in fields:
        f.write(f"\tl {unit_ctx.string_sym(field.name)}, l 0 #kFieldTypeStrongObject,\n")
    f.write("}\n")

    methods: list[MethodDecl] = list(filter(lambda x: isinstance(x, MethodDecl), cls.members))
    f.write(f"data ${cls.name}_instanceMethods = {{\n")
    for method in methods:
        f.write(f"\tl {unit_ctx.string_sym(method.name)}, l ${cls.name}_{method.name},\n")
    f.write("}\n")

    f.write(f"export data ${cls.name} = {{\n")
    f.write(f"\tl {unit_ctx.string_sym(cls.name)},\n")
    f.write(f"\tl ${cls.super},\n")
    f.write(f"\tl {len(fields)}, l ${cls.name}_fields,\n")
    f.write(f"\tl 0, l 0,\n")
    f.write(f"\tl {len(methods)}, l ${cls.name}_instanceMethods\n")
    f.write("}\n\n")

    f.write(f"# ==== \"{cls.name}\" Methods ==== \n")
    for method in methods:
        compile_method(f, method, cls, unit_ctx)
    f.write("\n")

def compile_ir(f, classes: list[ClassDecl]):
    f.write("# ==== Generated by zrlang ==== \n\n")

    unit_ctx = UnitContext()

    for cls in classes:
        compile_cls(f, cls, unit_ctx)

    f.write("# ==== String Data ==== \n")
    f.write(f"data $strings = {{ b \"{unit_ctx.string_data}\" }}")