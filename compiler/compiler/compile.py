import sys
from typing import Optional

from compiler.unit_context import UnitContext
from lang_ast import ClassDecl, ClassField, MethodDecl, VarStmt, _Statement, IntExpr, LocalExpr, AllocExpr, CallStmt, \
    MemberExpr, _Expression, CallExpr


depth = 0 # TODO

def expr_into_local(f, expr: _Expression, unit_ctx: UnitContext, *, local: Optional[str] = None) -> str:
    def get_temp_sym() -> str: # TODO: No ARC...
        if local is not None: return f"%{local}"
        global depth
        sym = f"%_temp{depth}"
        depth += 1
        return sym

    if isinstance(expr, IntExpr):
        return f"{expr.value}"
    elif isinstance(expr, LocalExpr):
        return f"%{expr.local}"
    elif isinstance(expr, MemberExpr):
        sym = expr_into_local(f, expr.expr, unit_ctx)
        temp = get_temp_sym()
        f.write(f"\t%_str =l add $strings, {unit_ctx.string_offset(expr.member)}\n")
        f.write(f"\t{temp} =l call $zre_get_field(l {sym}, l %_str)\n")
        return temp
    elif isinstance(expr, CallExpr):
        call = expr
        if isinstance(call.callee, MemberExpr):
            sym = expr_into_local(f, call.callee.expr, unit_ctx)
            args = ", ".join(f"l {expr_into_local(f, symbol, unit_ctx)}" for symbol in call.args)

            f.write(f"\t%_str =l add $strings, {unit_ctx.string_offset(call.callee.member)}\n")
            f.write(f"\t%_fn =l call $zre_method_virtual(l {sym}, l %_str)\n")
            temp = get_temp_sym()
            f.write(f"\t{temp} =l call %_fn(l {sym}, {args})\n")
            return temp
        else:
            sys.exit("Not a callable stmt!")
    else:
        sys.exit(f"Unsupported expr {expr}")

def compile_block(f, block: list[_Statement], unit_ctx: UnitContext):
    locals_to_release: list[str] = []

    for stmt in block:
        if isinstance(stmt, VarStmt):
            if stmt.expr is None:
                f.write(f"\t%{stmt.local} =l copy 0\n")
            elif isinstance(stmt.expr, IntExpr):
                f.write(f"\t%{stmt.local} =l copy {stmt.expr.value}\n")
            elif isinstance(stmt.expr, LocalExpr):
                f.write(f"\t%{stmt.local} =l copy %{stmt.expr.local}\n")
            elif isinstance(stmt.expr, AllocExpr):
                f.write(f"\t%{stmt.local} =l call $zre_alloc(l ${stmt.expr.cls_name})\n")
                locals_to_release.append(stmt.local)

        elif isinstance(stmt, CallStmt):
            expr_into_local(f, stmt.call, unit_ctx)

        else:
            sys.exit("Statement not supported yet!")

    for local in locals_to_release:
        f.write(f"\tcall $zre_release(l %{local})\n")

def compile_method(f, method: MethodDecl, cls: ClassDecl, unit_ctx: UnitContext):
    f.write(f"function l ${cls.name}_{method.name}(l %self) {{\n")
    f.write("@start\n")
    compile_block(f, method.block, unit_ctx)
    f.write("\tret\n")
    f.write("}\n")

# TODO: Clang throws a tantrum if _fields or _instanceMethods are empty
def compile_cls(f, cls: ClassDecl, unit_ctx: UnitContext):
    f.write(f"# ==== \"{cls.name}\" Class Definition ==== \n")
    fields: list[ClassField] = list(filter(lambda x: isinstance(x, ClassField), cls.members))
    f.write(f"data ${cls.name}_fields = {{\n")
    for field in fields:
        f.write(f"\tl {unit_ctx.string_sym(field.name)}, l 0,\n")
    f.write("}\n")

    methods: list[MethodDecl] = list(filter(lambda x: isinstance(x, MethodDecl), cls.members))
    f.write(f"data ${cls.name}_instanceMethods = {{\n")
    for method in methods:
        f.write(f"\tl {unit_ctx.string_sym(method.name)}, l ${cls.name}_{method.name},\n")
    f.write("}\n")

    f.write(f"export data ${cls.name} = {{\n")
    f.write(f"\tl {unit_ctx.string_sym(cls.name)},\n")
    if cls.super is None:
        f.write(f"\tl 0,\n")
    else:
        f.write(f"\tl ${cls.super},\n")
    f.write(f"\tl {len(fields)}, l ${cls.name}_fields,\n")
    f.write(f"\tl 0, l 0,\n")
    f.write(f"\tl {len(methods)}, l ${cls.name}_instanceMethods\n")
    f.write("}\n\n")

    f.write(f"# ==== \"{cls.name}\" Methods ==== \n")
    for method in methods:
        compile_method(f, method, cls, unit_ctx)
    f.write("\n")

def compile_ir(f, classes: list[ClassDecl]):
    f.write("# ==== Generated by zrlang ==== \n\n")

    unit_ctx = UnitContext()

    for cls in classes:
        compile_cls(f, cls, unit_ctx)

    f.write("# ==== String Data ==== \n")
    f.write(f"data $strings = {{ b \"{unit_ctx.string_data}\" }}")